"-------------------------------------------------------------------------------
" NeoBundle
"-------------------------------------------------------------------------------

" Note: Skip initialization for vim-tiny or vim-small.
if !1 | finish | endif

if has('vim_starting')
  if &compatible
    set nocompatible               " Be iMproved
  endif

  " Required:
  set runtimepath+=~/.vim/bundle/neobundle.vim/
endif

" Required:
call neobundle#begin(expand('~/.vim/bundle/'))

" Let NeoBundle manage NeoBundle
" Required:
NeoBundleFetch 'Shougo/neobundle.vim'

source ~/.vim.bundles.vim

call neobundle#end()

" Required:
filetype plugin indent on

" If there are uninstalled bundles found on startup,
" this will conveniently prompt you to install them.
NeoBundleCheck

"-------------------------------------------------------------------------------
" Basics
"-------------------------------------------------------------------------------

syntax on
set background=dark

if filereadable(expand("~/.vim/bundle/vim-colors-solarized/colors/solarized.vim"))
  let g:solarized_termcolors=256
  let g:solarized_termtrans=1
  let g:solarized_contrast="normal"
  let g:solarized_visibility="normal"
  color solarized
endif

" Use <Leader> in global plugin.
let g:mapleader = ','
" Use <LocalLeader> in filetype plugin.
let g:maplocalleader = 'm'

set textwidth=80
set tabstop=2
set shiftwidth=2
set softtabstop=2
set expandtab
set rnu
set nobackup
set nowritebackup
set noswapfile
set mouse=a
set list
set listchars=""                " Reset the listchars
set listchars=tab:\ \           " a tab should display as "  ", trailing whitespace as "."
set listchars+=trail:.          " show trailing spaces as dots
set listchars+=extends:>        " The character to show in the last column when wrap is
                                " off and the line continues beyond the right of the screen
set listchars+=precedes:<       " The character to show in the last column when wrap is
                                " off and the line continues beyond the right of the screen
set autoread                    " Automatically read
set cursorline                  " Highlight current line
set backspace=indent,eol,start  " Backspace for dummies
set linespace=0                 " No extra spaces between rows
set number                      " Line numbers on
set showmatch                   " Show matching brackets/parenthesis
set incsearch                   " Find as you type search
set hlsearch                    " Highlight search terms
set winminheight=0              " Windows can be 0 line high
set ignorecase                  " Case insensitive search
set smartcase                   " Case sensitive when uc present
set wildmenu                    " Show list instead of just completing
set wildmode=list:longest,full  " Command <Tab> completion, list matches, then longest common part, then all.
set whichwrap=b,s,h,l,<,>,[,]   " Backspace and cursor keys wrap too
set scrolljump=5                " Lines to scroll when cursor leaves screen
set scrolloff=3                 " Minimum lines to keep above and below cursor
set nofoldenable                " Disable auto fold code
set nojoinspaces                " Prevents inserting two spaces after punctuation on a join (J)
set splitright                  " Puts new vsplit windows to the right of the current
set splitbelow                  " Puts new split windows to the bottom of the current
set pastetoggle=<F12>           " pastetoggle (sane indentation on pastes)
set colorcolumn=+1              " Highlight 81st column
" Highlight when CursorMoved.
set cpoptions-=m
set matchtime=1

" FileType specific

"" {{{ Clojure
augroup ft_clojure
  "" testing
  au FileType clojure setlocal lispwords+=describe,it,testing,facts,fact,provided
  "" jdbc
  au FileType clojure setlocal lispwords+=with-connection,with-query-results,with-naming-strategy,with-quoted-identifiers,update-or-insert-values,insert-record,delete-rows,insert!
  "" core.async
  au FileType clojure setlocal lispwords+=go-loop
  "" carmine (redis)
  au FileType clojure setlocal lispwords+=wcar
  "" ClojureScript
  au FileType clojure setlocal lispwords+=this-as

  " Indent top-level form.
  au FileType clojure nmap <buffer> <localleader>= mz99[(v%='z

  "" TODO: visual bindings
  au Filetype clojure nnoremap <localleader>ee :Eval<CR>
  au Filetype clojure nnoremap <localleader>ef :%Eval<CR>
  au Filetype clojure nnoremap <localleader>er :Require<CR>
  au Filetype clojure nnoremap <localleader>eR :Require!<CR>
  au Filetype clojure nnoremap <localleader>r :call fireplace#eval("(user/reset)")<CR>
augroup END

augroup prismatic
  au FileType clojure setlocal lispwords+=fnk,defnk,for-map,letk
  au FileType clojure setlocal lispwords+=go-loop
  au FileType clojure setlocal lispwords+=this-as

  let g:clojure_align_subforms = 1
  let g:clojure_align_multiline_strings = 1
  let g:clojure_special_indent_words = 'deftype,defrecord,defprotocol,reify,proxy,extend-type,extend-protocol,letfn,implement,specify,specify!,' .
        \ 'defcomponent,defcomponentk,defcomponentmethod,defmixin'
augroup END

autocmd BufNewFile,BufReadPost *.cljx setfiletype clojure
au BufRead,BufNewFile *.edn setfiletype clojure
au BufRead,BufNewFile *.cljc setfiletype clojure

"-------------------------------------------------------------------------------
" Abbreviations
"-------------------------------------------------------------------------------
iabbrev ldis ಠ_ಠ
iabbrev lsad ಥ_ಥ
iabbrev lhap ಥ‿ಥ
iabbrev lmis ಠ‿ಠ

"-------------------------------------------------------------------------------
" Mappings
"-------------------------------------------------------------------------------
"

" Easier moving in tabs and windows
map <C-J> <C-W>j
map <C-K> <C-W>k
map <C-L> <C-W>l
map <C-H> <C-W>h
map <S-L> gt
map <S-H> gT

" Wrapped lines goes down/up to next row, rather than next line in file.
noremap j gj
noremap k gk

" Disable Ex mode
map Q <Nop>

" Some helpers to edit mode
" http://vimcasts.org/e/14
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%
noremap <Leader>dt :tabnew<Enter><Leader>d

" Last tab binding
let g:lasttab = 1
nmap <c-w>; :exe "tabn ".g:lasttab<cr>
au TabLeave * let g:lasttab = tabpagenr()

" Safely alias :we to :w
cnoreabbrev <expr> we ((getcmdtype() is# ':' && getcmdline() is# 'w')?('we'):('w'))

" Don't move on *
nnoremap * *<c-o>

" Keep search matches in the middle of the window.
nnoremap n nzzzv
nnoremap N Nzzzv

" Tab close
nnoremap <Leader>C :tabc<CR>

" Yank from the cursor to the end of the line, to be consistent with C and D.
nnoremap Y y$

" Stupid shift key fixes
command! -bang -nargs=* -complete=file E e<bang> <args>
command! -bang -nargs=* -complete=file W w<bang> <args>
command! -bang -nargs=* -complete=file Wq wq<bang> <args>
command! -bang -nargs=* -complete=file WQ wq<bang> <args>
command! -bang Wa wa<bang>
command! -bang WA wa<bang>
command! -bang Q q<bang>
command! -bang QA qa<bang>
command! -bang Qa qa<bang>
cmap Tabe tabe

" Shortcuts to change working directory to that of the current file
cmap cwd lcd %:p:h
cmap cd. lcd %:p:h

" Visual shifting (does not exit Visual mode)
vnoremap < <gv
vnoremap > >gv

" Fix home and end keybindings for screen, particularly on mac
" - for some reason this fixes the arrow keys too. huh.
map [F $
imap [F $
map [H g0
imap [H g0

" leader - q closes all buffers in tab
map <leader>q :tabclose

"-------------------------------------------------------------------------------
" Plugin Settings
"-------------------------------------------------------------------------------

" delimitMate
let delimitMate_quotes = "\" \'"
let delimitMate_smart_quotes = 0

" kein/rainbow_parens.vim
au VimEnter * RainbowParenthesesToggle
au Syntax * RainbowParenthesesLoadRound
au Syntax * RainbowParenthesesLoadSquare
au Syntax * RainbowParenthesesLoadBraces
"  Parentheses colours using Solarized"
let g:rbpt_colorpairs = [
  \ [ '13', '#6c71c4'],
  \ [ '5',  '#d33682'],
  \ [ '1',  '#dc322f'],
  \ [ '9',  '#cb4b16'],
  \ [ '3',  '#b58900'],
  \ [ '2',  '#859900'],
  \ [ '6',  '#2aa198'],
  \ [ '4',  '#268bd2'],
  \ ]

" jslint
let $JS_CMD='node'

" airline
let g:airline_powerline_fonts = 1
let g:airline#extensions#tabline#enabled = 1

" CtrlP
let g:ctrlp_switch_buffer = 0
let g:ctrlp_working_path_mode = 'r'

let g:ctrlp_user_command = {
    \ 'types': {
      \ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'],
      \ 2: ['.hg', 'hg --cwd %s locate -I .'],
      \ },
    \ 'fallback': 'find %s -type f'
  \ }

 let g:ctrlp_custom_ignore = {
       \ 'file': '\.exe$\|\.so$\|\.dll$\|\.pyc$',
       \ 'dir': '\.git$\|\.hg$\|\.svn$\|\.repl'
       \ }

" Ack
nnoremap <leader>a :Ack!<space>
let g:ackprg = 'ag --nogroup --nocolor --column'

" Tagbar
"" Move focus to tagbar when it opens to make it usable for windows on right side
let g:tagbar_autofocus = 1

" Tabularize
nmap <Leader>a- :Tabularize /=><CR>
vmap <Leader>a- :Tabularize /=><CR>

" vim-indent-guides
let g:indent_guides_enable_on_vim_startup = 0

" vim-gitgutter
let g:gitgutter_eager = 0

" vim-jsx
let g:jsx_ext_required = 0

"-------------------------------------------------------------------------------
" General Settings & Modifications
"-------------------------------------------------------------------------------

" Use clipboard register.
if has('unnamedplus')
  set clipboard& clipboard+=unnamedplus
else
  set clipboard& clipboard+=unnamed
endif

" Disable session dialog
let g:session_autosave='no'

" Tabline modifications
if has('gui')
  set guioptions-=e
endif
if exists("+showtabline")
  function! MyTabLine()
    let s = ''
    let t = tabpagenr()
    let i = 1
    while i <= tabpagenr('$')
      let buflist = tabpagebuflist(i)
      let winnr = tabpagewinnr(i)
      let s .= '%' . i . 'T'
      let s .= (i == t ? '%1*' : '%2*')
      let s .= ' '
      let s .= i . ':'
      let s .= winnr . '/' . tabpagewinnr(i,'$')
      let s .= ' %*'
      let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
      let bufnr = buflist[winnr - 1]
      let file = bufname(bufnr)
      let buftype = getbufvar(bufnr, 'buftype')
      if buftype == 'nofile'
        if file =~ '\/.'
          let file = substitute(file, '.*\/\ze.', '', '')
        endif
      else
        let file = fnamemodify(file, ':p:t')
      endif
      if file == ''
        let file = '[No Name]'
      endif
      let s .= file
      let i = i + 1
    endwhile
    let s .= '%T%#TabLineFill#%='
    let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
    return s
  endfunction
  set stal=2
  set tabline=%!MyTabLine()
endif
