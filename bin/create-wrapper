#!/usr/bin/env bash

set -euo pipefail

usage() {
  cat <<'EOF'
Usage: create-wrapper [OPTIONS] <executable> <wrapper-output-path>

Create a wrapper script using nixpkgs makeWrapper.

ARGUMENTS:
    <executable>         Path to the executable to wrap
    <wrapper-output-path> Path where the wrapper script will be created

OPTIONS:
    --prefix NAME VALUE       Prefix environment variable NAME with VALUE
    --suffix NAME VALUE       Suffix environment variable NAME with VALUE  
    --set NAME VALUE          Set environment variable NAME to VALUE
    --set-default NAME VALUE  Set environment variable NAME to VALUE if unset
    --set-from-op NAME OPREF  Set environment variable NAME from 1Password reference
    --set-default-from-op NAME OPREF  Set environment variable NAME from 1Password reference if unset
    --unset NAME              Unset environment variable NAME
    --run COMMAND             Run COMMAND before the executable
    --add-flags FLAGS         Add FLAGS to the executable command line
    --append-flags FLAGS      Append FLAGS to the executable command line
    --impure                  Allow executable to be resolved from PATH at runtime
    --help, -h                Show this help message

EXAMPLES:
    create-wrapper /usr/bin/node ./my-node-wrapper --set NODE_ENV production
    create-wrapper ./app ./wrapped-app --prefix PATH : /opt/bin --add-flags "--verbose"
    create-wrapper /usr/bin/app ./secure-app --set-from-op API_KEY "op://Private/API Keys/api_key"
    create-wrapper node ./my-node-wrapper --impure --set NODE_ENV production
    create-wrapper git ./my-git --impure --set-from-op GH_TOKEN "op://Private/GitHub/token"
EOF
}

cleanup() {
  if [[ -n "${TMPDIR_WRAPPER:-}" && -d "$TMPDIR_WRAPPER" ]]; then
    rm -rf "$TMPDIR_WRAPPER"
  fi
}

trap cleanup EXIT INT TERM

main() {
  local executable=""
  local output_path=""
  local wrapper_args=()
  local op_secrets=()
  local impure_mode=false

  while [[ $# -gt 0 ]]; do
    case $1 in
    --help | -h)
      usage
      exit 0
      ;;
    --impure)
      impure_mode=true
      shift
      ;;
    --prefix | --suffix | --set | --set-default)
      if [[ $# -lt 3 ]]; then
        echo "Error: $1 requires NAME and VALUE arguments" >&2
        exit 1
      fi
      wrapper_args+=("$1" "$2" "$3")
      shift 3
      ;;
    --set-from-op | --set-default-from-op)
      if [[ $# -lt 3 ]]; then
        echo "Error: $1 requires NAME and 1PASSWORD_REFERENCE arguments" >&2
        exit 1
      fi
      if [[ ! "$3" =~ ^op:// ]]; then
        echo "Error: 1Password reference must start with 'op://'" >&2
        exit 1
      fi
      op_secrets+=("$1" "$2" "$3")
      shift 3
      ;;
    --unset | --run | --add-flags | --append-flags)
      if [[ $# -lt 2 ]]; then
        echo "Error: $1 requires an argument" >&2
        exit 1
      fi
      wrapper_args+=("$1" "$2")
      shift 2
      ;;
    -*)
      echo "Error: Unknown option $1" >&2
      usage >&2
      exit 1
      ;;
    *)
      if [[ -z "$executable" ]]; then
        executable="$1"
      elif [[ -z "$output_path" ]]; then
        output_path="$1"
      else
        echo "Error: Too many positional arguments" >&2
        usage >&2
        exit 1
      fi
      shift
      ;;
    esac
  done

  if [[ -z "$executable" || -z "$output_path" ]]; then
    echo "Error: Both executable and output path are required" >&2
    usage >&2
    exit 1
  fi

  if [[ "$impure_mode" == "true" ]]; then
    # In impure mode, allow command names that will be resolved from PATH at runtime
    if ! command -v "$executable" >/dev/null 2>&1; then
      echo "Warning: Command '$executable' not found in current PATH. Wrapper will attempt to resolve at runtime." >&2
    fi
  else
    # Default strict mode: require absolute path to existing executable
    if [[ ! -f "$executable" ]]; then
      echo "Error: Executable '$executable' does not exist" >&2
      echo "Use --impure flag to allow runtime PATH resolution" >&2
      exit 1
    fi
    if [[ ! -x "$executable" ]]; then
      echo "Error: '$executable' is not executable" >&2
      exit 1
    fi
  fi

  create_wrapper_with_nix "$executable" "$output_path" "$impure_mode" "${wrapper_args[@]}" "${op_secrets[@]}"
}

create_wrapper_with_nix() {
  local executable="$1"
  local output_path="$2"
  local impure_mode="$3"
  shift 3

  local wrapper_args=()
  local op_secrets=()
  local parsing_secrets=false

  for arg in "$@"; do
    if [[ "$arg" == "--set-from-op" || "$arg" == "--set-default-from-op" ]]; then
      parsing_secrets=true
      op_secrets+=("$arg")
    elif [[ "$parsing_secrets" == true ]]; then
      op_secrets+=("$arg")
    else
      wrapper_args+=("$arg")
    fi
  done

  TMPDIR_WRAPPER=$(mktemp -d)
  local nix_file="$TMPDIR_WRAPPER/wrapper.nix"
  local result_path="$TMPDIR_WRAPPER/result"

  local executable_for_nix
  if [[ "$impure_mode" == "true" ]]; then
    executable_for_nix="$executable"
  else
    executable_for_nix=$(realpath "$executable")
  fi

  local output_abs
  output_abs=$(realpath -m "$output_path")
  local output_dir
  output_dir=$(dirname "$output_abs")

  if [[ ! -d "$output_dir" ]]; then
    mkdir -p "$output_dir"
  fi

  cat >"$nix_file" <<'EOF'
{ pkgs ? import <nixpkgs> {} }:

let
  executable = builtins.getEnv "WRAPPER_EXECUTABLE";
  impureMode = builtins.getEnv "WRAPPER_IMPURE" == "true";
  wrapperArgs = builtins.fromJSON (builtins.getEnv "WRAPPER_ARGS");
  opSecrets = builtins.fromJSON (builtins.getEnv "OP_SECRETS");
  
  # Generate --run commands for 1Password secret resolution
  opCommands = builtins.concatStringsSep " " (
    pkgs.lib.imap0 (i: secret: 
      let
        flag = builtins.elemAt secret 0;
        varName = builtins.elemAt secret 1;
        opRef = builtins.elemAt secret 2;
        setType = if flag == "--set-from-op" then "--set" else "--set-default";
      in
        "--run ${pkgs.lib.escapeShellArg "export ${varName}=$(op read ${pkgs.lib.escapeShellArg opRef})"}"
    ) opSecrets
  );
in

pkgs.stdenv.mkDerivation {
  name = "wrapper-generator";
  
  buildInputs = [ pkgs.makeWrapper ];
  
  phases = [ "buildPhase" ];
  
  buildPhase = ''
    mkdir -p $out/bin
    ${if impureMode then 
      "makeWrapper ${pkgs.lib.escapeShellArg "$(command -v ${pkgs.lib.escapeShellArg executable} || echo ${pkgs.lib.escapeShellArg executable})"} $out/bin/wrapper ${opCommands} ${pkgs.lib.concatStringsSep " " (map pkgs.lib.escapeShellArg wrapperArgs)}"
    else
      "makeWrapper ${pkgs.lib.escapeShellArg executable} $out/bin/wrapper ${opCommands} ${pkgs.lib.concatStringsSep " " (map pkgs.lib.escapeShellArg wrapperArgs)}"
    }
  '';
}
EOF

  local wrapper_args_json op_secrets_json
  wrapper_args_json=$(printf '%s\n' "${wrapper_args[@]}" | jq -R . | jq -s .)

  if [[ ${#op_secrets[@]} -gt 0 ]]; then
    op_secrets_json=$(printf '%s\n' "${op_secrets[@]}" | jq -R . | jq -s . | jq '[. as $arr | range(0; length; 3) | [$arr[.], $arr[.+1], $arr[.+2]]]')
  else
    op_secrets_json='[]'
  fi

  WRAPPER_EXECUTABLE="$executable_for_nix" \
    WRAPPER_IMPURE="$impure_mode" \
    WRAPPER_ARGS="$wrapper_args_json" \
    OP_SECRETS="$op_secrets_json" \
    nix-build "$nix_file" -o "$result_path" --no-out-link

  if [[ ! -f "$result_path/bin/wrapper" ]]; then
    echo "Error: Failed to generate wrapper" >&2
    exit 1
  fi

  cp "$result_path/bin/wrapper" "$output_path"
  chmod +x "$output_path"

  echo "Wrapper created: $output_path"
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  main "$@"
fi
