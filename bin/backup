#!/usr/bin/env bash

# Copyright 2021 Logan Linn
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

set -e
set -u
set -o pipefail
[[ -z ${TRACE-} ]] || set -x

[[ -z ${BACKUP_IN_BACKUPRC-} ]] || exit 2

XDG_CONFIG_HOME=${XDG_CONFIG_HOME-$HOME/.config}

backup=$0

backup_config_dir=$XDG_CONFIG_HOME/backup

backup_log_format=${backup_log_format-"$(basename "$backup"): %b"}

declare -a _backup_flags
declare -a _backup_paths

# Usage: log_status [<message> ...]
#
# Logs a status message. Acts like echo,
# but wraps output in the standard direnv log format
#
#
# Usage: log_status [<message> ...]
#
#
# Logs a status message. Acts like echo,
# but wraps output in the standard direnv log format
# (controlled by $backup_log_format), and directs it
# to stderr rather than stdout.
#
# Example:
#
#    log_status "Loading ..."
#
log_status() {
	if [[ -n $backup_log_format ]]; then
		# shellcheck disable=SC2059,SC1117
		printf "${backup_log_format}\n" "$*" >&2
	fi
}

# Usage: log_error [<message> ...]
#
# Logs an error message. Acts like echo,
# but wraps output in the standard direnv log format
# (controlled by $backup_log_format), and directs it
# to stderr rather than stdout.
#
# Example:
#
#    log_error "Unable to find specified directory!"
log_error() {
	if [[ -n $backup_log_format ]]; then
		printf "$(tput setaf 1)${backup_log_format}$(tput sgr0)\n" "$*" >&2
	fi
}

# Usage: has <command>
#
# Returns 0 if the <command> is available. Returns 1 otherwise. It can be a
# binary in the PATH or a shell function.
#
# Example:
#
#    if has curl; then
#      echo "Yes we do"
#    fi
#
has() {
	type "$1" &>/dev/null
}

#
#
#
backup_exclude() {
	for _pattern; do
		[[ -z $_pattern ]] || _backup_flags+=(--exclude "$_pattern")
	done
}

#
#
#
backup_exclude_file() {
	for _file; do
		[[ -z $_file ]] || _backup_flags+=(--exclude-file "$_file")
	done
}

#
#
#
backup_iexclude() {
	for _pattern; do
		[[ -z $_pattern ]] || _backup_flags+=(--iexclude "$_pattern")
	done
}

#
#
#
backup_iexclude_file() {
	for _file; do
		[[ -z $_file ]] || _backup_flags+=(--iexclude-file "$_file")
	done
}

#
#
#
backup_option() {
	[[ $# -eq 2 ]] || return 1
	_backup_flags+=(--option "$1=$2")
}

#
#
#
backup_tag() {
	[[ $# -eq 1 ]] || return 1
	_backup_flags+=(--tag "$1")
}

#------------------------------------------------------------

for _backuprc in ~/.backuprc "$backup_config_dir"/backuprc; do
	if [[ -e $_backuprc ]]; then
		log_status "Loading '$_backuprc'"
		export BACKUP_IN_BACKUPRC=1
		# shellcheck disable=SC1091
		. "$_backuprc"
		unset BACKUP_IN_BACKUPRC
		break
	fi
done

if [[ -e $backup_config_dir/exclude ]]; then
	backup_exclude_file "$backup_config_dir/exclude"
fi

if [[ -e $backup_config_dir/iexclude ]]; then
	backup_iexclude_file "$backup_config_dir/iexclude"
fi

if [[ -n ${QUIET-} ]]; then
	_backup_flags+=(--quiet)
fi

declare -a _backup_args=("${_backup_flags[@]}" "${_backup_paths[@]}" "$@")

log_status "Running: $(printenv | grep '^RESTIC_' | xargs echo || true) restic backup ${_backup_args[*]}"

[[ -z ${DRY_RUN-} ]] || exit 0

echo

exec restic backup "${_backup_args[@]}"
